# -*- coding: utf-8 -*-
"""Genetique.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K055webmTX8lFIuPwtNKJgrkYG8Hifso
"""

!pip install numpy pandas matplotlib

print("‚úÖ Biblioth√®ques install√©es avec succ√®s!")

from google.colab import files
import pandas as pd

print("üìÅ Veuillez s√©lectionner votre fichier VRPTW_dataset_100.csv")
uploaded = files.upload()

# R√©cup√©rer le nom du fichier
filename = list(uploaded.keys())[0]
print(f"‚úÖ Fichier charg√©: {filename}")

import pandas as pd

df = pd.read_csv('VRPTW_dataset_100.csv')
print("üìä Aper√ßu des donn√©es:")
print(df.head())
print(f"\nüìè Dimensions: {df.shape}")
print(f"‚úÖ {len(df)-1} clients charg√©s")

# Cellule 4 - Algorithme g√©n√©tique VRPTW
import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt
import time

class AlgorithmeGenetiqueVRPTW:
    def __init__(self, df, capacite, taille_pop=100, generations=500,
                 taux_croisement=0.8, taux_mutation=0.1):
        """
        Algorithme g√©n√©tique pour VRPTW
        """
        self.df = df
        self.nb_clients = len(df) - 1
        self.capacite = capacite

        # Calculer la matrice des distances
        self.distances = self.calculer_matrice_distances()

        # Extraire les donn√©es
        self.ready_time = df['ready_time'].values
        self.due_time = df['due_time'].values
        self.service_time = df['service_time'].values
        self.x = df['x'].values
        self.y = df['y'].values

        # Param√®tres AG
        self.taille_pop = taille_pop
        self.generations = generations
        self.taux_croisement = taux_croisement
        self.taux_mutation = taux_mutation

        self.population = []
        self.meilleure_solution = None
        self.meilleur_cout = float('inf')
        self.historique_cout = []

        self.clients = list(range(1, self.nb_clients + 1))

        print(f"\nüìä Configuration:")
        print(f"   - Clients: {self.nb_clients}")
        print(f"   - Capacit√©: {capacite}")
        print(f"   - Population: {taille_pop}")
        print(f"   - G√©n√©rations: {generations}")

    def calculer_matrice_distances(self):
        """Calcule la matrice des distances"""
        coords = self.df[['x', 'y']].values
        n = len(coords)
        distances = np.zeros((n, n))

        for i in range(n):
            for j in range(n):
                distances[i][j] = np.sqrt(np.sum((coords[i] - coords[j])**2))

        return distances

    def initialiser_population(self):
        """Population initiale"""
        self.population = []
        for _ in range(self.taille_pop):
            solution = self.clients.copy()
            random.shuffle(solution)
            self.population.append(solution)

    def decoder_solution(self, solution):
        """
        D√©code une solution en routes respectant contraintes
        """
        routes = []
        route_actuelle = [0]
        charge_actuelle = 0
        temps_actuel = 0
        dernier_point = 0

        for client in solution:
            trajet = self.distances[dernier_point][client]
            arrivee = temps_actuel + trajet

            if arrivee < self.ready_time[client]:
                arrivee = self.ready_time[client]

            depart = arrivee + self.service_time[client]
            demande = 1

            if (charge_actuelle + demande <= self.capacite and
                arrivee <= self.due_time[client]):

                route_actuelle.append(client)
                charge_actuelle += demande
                temps_actuel = depart
                dernier_point = client
            else:
                route_actuelle.append(0)
                routes.append(route_actuelle)

                route_actuelle = [0, client]
                charge_actuelle = demande

                trajet_nouveau = self.distances[0][client]
                arrivee_nouveau = trajet_nouveau
                if arrivee_nouveau < self.ready_time[client]:
                    arrivee_nouveau = self.ready_time[client]
                temps_actuel = arrivee_nouveau + self.service_time[client]
                dernier_point = client

        if len(route_actuelle) > 1:
            route_actuelle.append(0)
            routes.append(route_actuelle)

        return routes

    def calculer_cout_route(self, route):
        """Calcule le co√ªt d'une route"""
        distance = 0
        penalite_temps = 0
        temps_actuel = 0
        dernier_point = 0

        for i in range(1, len(route) - 1):
            client = route[i]

            trajet = self.distances[dernier_point][client]
            distance += trajet
            arrivee = temps_actuel + trajet

            if arrivee > self.due_time[client]:
                penalite_temps += (arrivee - self.due_time[client]) * 100

            if arrivee < self.ready_time[client]:
                arrivee = self.ready_time[client]

            temps_actuel = arrivee + self.service_time[client]
            dernier_point = client

        if len(route) > 2:
            distance += self.distances[dernier_point][0]

        return distance + penalite_temps

    def evaluer_fitness(self, solution):
        """√âvalue une solution"""
        routes = self.decoder_solution(solution)

        if not routes:
            return 0

        cout_total = sum(self.calculer_cout_route(route) for route in routes)
        cout_total += len(routes) * 50

        fitness = 1 / cout_total if cout_total > 0 else 0

        if cout_total < self.meilleur_cout:
            self.meilleur_cout = cout_total
            self.meilleure_solution = solution.copy()

        return fitness

    def selection_tournoi(self, fitnesses, taille_tournoi=3):
        """S√©lection par tournoi"""
        meilleur_idx = None
        meilleure_fitness = -1

        for _ in range(taille_tournoi):
            idx = random.randint(0, len(self.population) - 1)
            if fitnesses[idx] > meilleure_fitness:
                meilleure_fitness = fitnesses[idx]
                meilleur_idx = idx

        return meilleur_idx

    def croisement_ox(self, parent1, parent2):
        """Croisement OX"""
        if random.random() > self.taux_croisement:
            return parent1.copy(), parent2.copy()

        taille = len(parent1)
        debut = random.randint(0, taille - 2)
        fin = random.randint(debut + 1, taille - 1)

        enfant1 = [-1] * taille
        enfant2 = [-1] * taille

        enfant1[debut:fin] = parent1[debut:fin]
        enfant2[debut:fin] = parent2[debut:fin]

        pos1, pos2 = fin, fin
        for i in range(taille):
            idx = (fin + i) % taille

            if parent2[idx] not in enfant1:
                enfant1[pos1 % taille] = parent2[idx]
                pos1 += 1

            if parent1[idx] not in enfant2:
                enfant2[pos2 % taille] = parent1[idx]
                pos2 += 1

        return enfant1, enfant2

    def mutation_swap(self, solution):
        """Mutation par √©change"""
        if random.random() > self.taux_mutation:
            return solution

        solution = solution.copy()
        i, j = random.sample(range(len(solution)), 2)
        solution[i], solution[j] = solution[j], solution[i]
        return solution

    def evoluer(self):
        """Ex√©cute l'algorithme"""
        print("\nüîÑ D√©but de l'√©volution...")
        debut = time.time()

        self.initialiser_population()

        for generation in range(self.generations):
            fitnesses = [self.evaluer_fitness(sol) for sol in self.population]

            nouvelle_population = []

            meilleur_idx = np.argmax(fitnesses)
            nouvelle_population.append(self.population[meilleur_idx].copy())

            while len(nouvelle_population) < self.taille_pop:
                idx1 = self.selection_tournoi(fitnesses)
                idx2 = self.selection_tournoi(fitnesses)

                enfant1, enfant2 = self.croisement_ox(
                    self.population[idx1],
                    self.population[idx2]
                )

                enfant1 = self.mutation_swap(enfant1)
                enfant2 = self.mutation_swap(enfant2)

                nouvelle_population.extend([enfant1, enfant2])

            self.population = nouvelle_population[:self.taille_pop]
            self.historique_cout.append(self.meilleur_cout)

            if (generation + 1) % 50 == 0:
                print(f"   G√©n√©ration {generation + 1}: co√ªt = {self.meilleur_cout:.2f}")

        fin = time.time()
        print(f"\n‚úÖ √âvolution termin√©e en {fin - debut:.2f} secondes")

        return self.meilleure_solution, self.meilleur_cout

    def visualiser_routes(self, routes):
        """Visualise les routes"""
        plt.figure(figsize=(15, 10))

        # Clients
        for i in range(1, len(self.x)):
            plt.scatter(self.x[i], self.y[i], c='blue', s=50, alpha=0.6)
            plt.annotate(str(i), (self.x[i], self.y[i]), fontsize=8)

        # D√©p√¥t
        plt.scatter(self.x[0], self.y[0], c='red', s=200, marker='s', label='D√©p√¥t')

        # Routes
        couleurs = plt.cm.rainbow(np.linspace(0, 1, len(routes)))

        for idx, route in enumerate(routes):
            couleur = couleurs[idx]
            for i in range(len(route) - 1):
                debut = route[i]
                fin = route[i + 1]
                plt.plot([self.x[debut], self.x[fin]],
                        [self.y[debut], self.y[fin]],
                        c=couleur, linewidth=1.5, alpha=0.7)

        plt.title(f'Routes optimis√©es - {len(routes)} v√©hicules - Co√ªt: {self.meilleur_cout:.2f}')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

    def afficher_resultats(self, routes):
        """Affiche les r√©sultats"""
        print(f"\nüìà R√âSULTATS FINAUX")
        print("=" * 50)
        print(f"üèÜ Meilleur co√ªt: {self.meilleur_cout:.2f}")
        print(f"üöõ Nombre de v√©hicules: {len(routes)}")
        print(f"üìä Clients servis: {self.nb_clients}")

        for i, route in enumerate(routes, 1):
            nb_clients_route = len(route) - 2
            print(f"   Route {i}: {nb_clients_route} clients")

# Cellule 5 - Lancer l'algorithme
print("üöÄ LANCEMENT DE L'ALGORITHME")
print("=" * 50)

# Param√®tres
capacite_vehicule = 50  # √Ä ajuster selon ton probl√®me

# Cr√©er l'algorithme
ag = AlgorithmeGenetiqueVRPTW(
    df=df,
    capacite=capacite_vehicule,
    taille_pop=150,
    generations=300,
    taux_croisement=0.85,
    taux_mutation=0.15
)

# Ex√©cuter
meilleure_solution, meilleur_cout = ag.evoluer()

# Afficher les r√©sultats
routes = ag.decoder_solution(meilleure_solution)
ag.afficher_resultats(routes)

# Cellule 6 - Visualisation
print("üñºÔ∏è G√©n√©ration de la visualisation...")
ag.visualiser_routes(routes)

# Cellule 7 - Graphique de convergence
plt.figure(figsize=(10, 6))
plt.plot(ag.historique_cout, linewidth=2)
plt.title('üìâ Convergence de l\'algorithme g√©n√©tique')
plt.xlabel('G√©n√©ration')
plt.ylabel('Meilleur co√ªt')
plt.grid(True, alpha=0.3)
plt.show()

# Cellule 8 - Sauvegarde
with open('resultats_vrptw.txt', 'w') as f:
    f.write(f"Meilleur co√ªt: {meilleur_cout:.2f}\n")
    f.write(f"Nombre de v√©hicules: {len(routes)}\n\n")
    f.write("D√©tail des routes:\n")
    for i, route in enumerate(routes, 1):
        f.write(f"Route {i}: {route}\n")

print("‚úÖ R√©sultats sauvegard√©s dans 'resultats_vrptw.txt'")

# T√©l√©charger les r√©sultats
from google.colab import files
files.download('resultats_vrptw.txt')

# Cellule 9 - Sauvegarde dans Drive
from google.colab import drive
drive.mount('/content/drive')

# Copier les fichiers
!cp resultats_vrptw.txt /content/drive/MyDrive/ 2>/dev/null
!cp *.png /content/drive/MyDrive/ 2>/dev/null

print("‚úÖ Fichiers sauvegard√©s dans Google Drive")